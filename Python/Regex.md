# python正则表达式

Python 中所有正则表达式的函数都在re 模块中，包含所有正则表达式的功能。
```python
import re
```
由于Python的字符串本身也用\转义，所以要特别注意：
```python
s = 'ABC\\-001' # Python的字符串
# 对应的正则表达式字符串变成：
# 'ABC\-001'
因此我们强烈建议使用Python的r前缀，就不用考虑转义的问题了：

s = r'ABC\-001' # Python的字符串
# 对应的正则表达式字符串不变：
# 'ABC\-001'
```

## re.match函数
re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。

函数语法：

re.match(pattern, string, flags=0)

函数参数说明：

参数 | 描述
:--: | :--:
pattern	 | 匹配的正则表达式
string	 | 要匹配的字符串。
flags	 | 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志

匹配成功re.match方法返回一个匹配的对象，否则返回None。可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。

匹配对象方法	| 描述
:--: | :--:
group(num=0)	| 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。
groups()	| 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。


```python
test = '用户输入的字符串'
if re.match(r'正则表达式', test):
    print('ok')
else:
    print('failed')
```
## re.split
用正则表达式切分字符串比用固定的字符更灵活
```python
re.split(pattern, string[, maxsplit=0, flags=0])
```

```python
 'a b   c'.split(' ')
['a', 'b', '', '', 'c'] # 无法识别连续的空格


re.split(r'\s+', 'a b   c')
# ['a', 'b', 'c'] 无论多少个空格都可以正常分割


# 加入,试试：
re.split(r'[\s\,]+', 'a,b, c  d')
['a', 'b', 'c', 'd']

#再加入;试试：
re.split(r'[\s\,\;]+', 'a,b;; c  d')
['a', 'b', 'c', 'd']
```

## 分组
除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组（Group）。比如：

^(\d{3})-(\d{3,8})$分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：
```python
re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
# <_sre.SRE_Match object; span=(0, 9), match='010-12345'>

m.group(0)
# '010-12345'

m.group(1)
# '010'

m.group(2)
# '12345'
```


## 贪婪匹配
最后需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：
```python
re.match(r'^(\d+)(0*)$', '102300').groups()
('102300', '')
由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。

必须让\d+采用非贪婪匹配（也就是尽可能少匹配），才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配：

re.match(r'^(\d+?)(0*)$', '102300').groups()
('1023', '00')
```

##  re.compile
当我们在Python中使用正则表达式时，re模块内部会干两件事情：

+ 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；

+ 用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用时就不需要编译这个步骤了，直接匹配：
```python
import re
# 编译:
re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')
# 使用：
re_telephone.match('010-12345').groups()
('010', '12345')
re_telephone.match('010-8086').groups()
('010', '8086')
```
编译后生成Regular Expression对象，由于该对象自己包含了正则表达式，所以调用对应的方法时不用给出正则字符串。













正则表达式模式

|     模式     |                             描述                             |
| :----------: | :----------------------------------------------------------: |
|      ^       |                       匹配字符串的开头                       |
|      $       |                      匹配字符串的末尾。                      |
|      .       | 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 |
|    [...]     |     用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'      |
|    [^...]    |       不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。       |
|     re\*      |                   匹配0个或多个的表达式。                |
|     re+      |                   匹配1个或多个的表达式。                    |
|     re?      |     匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式     |
|    re{ n}    | 匹配n个前面表达式。例如，"o{2}"不能匹配"Bob"中的"o"，但是能匹配"food"中的两个o。 |
|   re{ n,}    | 精确匹配n个前面表达式。例如，"o{2,}"不能匹配"Bob"中的"o"，但能匹配"foooood"中的所有o。"o{1,}"等价于"o+"。"o{0,}"则等价于"o\*"。 |
|  re{ n, m}   |     匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式     |
|    a\| b     |                           匹配a或b                     |
|     (re)     |               匹配括号内的表达式，也表示一个组               |
|    (?imx)    | 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 |
|   (?-imx)    |   正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。   |
|   (?:re)    |                 类似 (...), 但是不表示一个组              |
|  (?imx:re)  |               在括号中使用i, m, 或 x 可选标志             |
| (?-imx:re)  |              在括号中不使用i, m, 或 x 可选标志            |
|   (?#...)    |                            注释.                       |
|   (?=re)    | 前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 |
|   (?!re)    | 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。 |
|   (?>re)    |                  匹配的独立模式，省去回溯。                  |
|      \w      |                      匹配数字字母下划线                  |
|      \W      |                     匹配非数字字母下划线                  |
|      \s      |            匹配任意空白字符，等价于 [\t\n\r\f]。             |
|      \S      |                       匹配任意非空字符                   |
|      \d      |                 匹配任意数字，等价于 [0-9]。              |
|      \D      |                        匹配任意非数字                    |
|      \A      |                        匹配字符串开始                    |
|      \Z      | 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 |
|      \z      |                        匹配字符串结束                    |
|      \G      |                   匹配最后匹配完成的位置。                |
|      \b      | 匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。 |
|      \B      | 匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。 |
| \n, \t, 等。 |              匹配一个换行符。匹配一个制表符, 等              |
|   \1...\9    |                    匹配第n个分组的内容。                  |
|     \10      | 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 |

------

## 正则表达式实例

#### 字符匹配

| 实例   | 描述           |
| :----- | :------------- |
| python | 匹配 "python". |

#### 字符类

| 实例        | 描述                              |
| :---------- | :-------------------------------- |
| [Pp]ython   | 匹配 "Python" 或 "python"         |
| rub[ye]     | 匹配 "ruby" 或 "rube"             |
| [aeiou]     | 匹配中括号内的任意一个字母        |
| [0-9]       | 匹配任何数字。类似于 [0123456789] |
| [a-z]       | 匹配任何小写字母                  |
| [A-Z]       | 匹配任何大写字母                  |
| [a-zA-Z0-9] | 匹配任何字母及数字                |
| [^aeiou]    | 除了aeiou字母以外的所有字符       |
| [^0-9]      | 匹配除了数字外的字符              |

#### 特殊字符类

| 实例 | 描述                                                         |
| :--- | :----------------------------------------------------------- |
| .    | 匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。 |
| \d   | 匹配一个数字字符。等价于 [0-9]。                             |
| \D   | 匹配一个非数字字符。等价于 [^0-9]。                          |
| \s   | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S   | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \w   | 匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。         |
| \W   | 匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。                 |





